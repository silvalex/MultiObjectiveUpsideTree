package ec.wsc;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import ec.Individual;
import ec.gp.GPNode;
import ec.multiobjective.nsga2.NSGA2MultiObjectiveFitness;
import ec.EvolutionState;
//import ec.multiobjective.nsga2.NSGA2MultiObjectiveFitness;
import ec.Fitness;
import ec.util.Code;
import ec.util.Parameter;

public class TreeIndividual extends Individual {
	private static final long serialVersionUID = 1L;
	private TreeNode root;
	private double availability;

	public double getAvailability() {
		return availability;
	}

	public void setAvailability(double availability) {
		this.availability = availability;
	}

	public double getReliability() {
		return reliability;
	}

	public void setReliability(double reliability) {
		this.reliability = reliability;
	}

	public double getTime() {
		return time;
	}

	public void setTime(double time) {
		this.time = time;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	private double reliability;
	private double time;
	private double cost;

	@Override
	public Parameter defaultBase() {
		return new Parameter("treeindividual");
	}

	@Override
	public boolean equals(Object other) {
		if (other instanceof TreeIndividual) {
			return toString().equals(other.toString());
		}
		return false;
	}

	@Override
	public int hashCode() {
		return toString().hashCode();
	}

	public void setRoot(TreeNode root) {
		this.root = root;
	}

	public TreeNode getRoot() {
		return root;
	}

	@Override
	/**
	 * A graphic representation of this candidate can be generated by saving this description to a .dot file and
	 * running the command "dot -Tpng filename.dot -o filename.png"
	 */
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("digraph g {");

		Queue<TreeNode> serviceQueue = new LinkedList<TreeNode>();
		serviceQueue.offer(root);

		while(!serviceQueue.isEmpty()) {
			TreeNode node = serviceQueue.poll();

			String serviceName = node.getService().getName();
			builder.append(String.format("%d [label=\"%s\"]; ", node.hashCode(), serviceName));
			if (node.getChildren() != null) {
				for (int i = 0; i < node.getChildren().size(); i++) {
					TreeNode child = node.getChildren().get(i);
					serviceQueue.offer(child);
					builder.append(String.format("%d -> %d [dir=back]; ", node.hashCode(), child.hashCode()));
				}
			}
		}

		builder.append("}");
		return builder.toString();
	}

	/**
	 * Used in copyTo method.
	 *
	 * @author sawczualex
	 */
	public class NodePair {
		public TreeNode original;
		public TreeNode copy;

		public NodePair(TreeNode original, TreeNode copy) {
			this.original = original;
			this.copy = copy;
		}
	}

	/**
	 * Copies this graph structure to another GraphIndividual object.
	 *
	 * @param other
	 */
    public void copyTo(TreeIndividual other) {
    	Queue<NodePair> queue = new LinkedList<NodePair>();

    	// Create the new root
    	if (root != null) {
	    	TreeNode newRoot = new TreeNode(root.getService());
	    	other.root = newRoot;

	    	// Create the new root's children
	    	for (TreeNode child : root.getChildren()) {
	    		TreeNode newChild = new TreeNode(child.getService());
	    		// Connect it to tree
	    		newChild.setParent(newRoot);
	    		newRoot.getChildren().add(newChild);
	    		// Add it to queue
	    		queue.offer(new NodePair(child, newChild));
	    	}

	    	while(!queue.isEmpty()) {
	    		NodePair pair = queue.poll();

	    		// Create the new node's children
	        	for (TreeNode child : pair.original.getChildren()) {
	        		TreeNode newChild = new TreeNode(child.getService());
	        		// Connect it to the new tree
	        		newChild.setParent(pair.copy);
	        		pair.copy.getChildren().add(newChild);
	        		// Add it to queue
	        		queue.offer(new NodePair(child, newChild));
	        	}
	    	}
    	}
    	else {
    		other.root = null;
    	}
    }

    @Override
    public TreeIndividual clone() {
    	TreeIndividual g = new TreeIndividual();
    	g.species = this.species;
    	if (this.fitness == null)
    		g.fitness = (Fitness) g.species.f_prototype.clone();
    	else
    		g.fitness = (Fitness) this.fitness.clone();
    	copyTo(g);
    	return g;
    }

    public void replaceNode(TreeNode oldNode, TreeNode newNode) {
    	TreeNode parent = oldNode.getParent();
    	parent.getChildren().remove(oldNode);
    	parent.getChildren().add(newNode);
    	newNode.setParent(parent);
    }

    public List<TreeNode> getAllTreeNodes() {
    	List<TreeNode> allNodes = new ArrayList<TreeNode>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();

        queue.offer(root);

        while(!queue.isEmpty()) {
            TreeNode current = queue.poll();
            allNodes.add(current);
            if (!current.getChildren().isEmpty()) {
                for (TreeNode child : current.getChildren()) {
                    allNodes.add( child );
                    queue.offer(child);
                }
            }
        }
    	return allNodes;
    }
}
